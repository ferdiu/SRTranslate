#!/bin/bash

PREFERRED_MAX_LINE_LENGTH=40

usage() {
    echo -e "usage:\t$0 <source lang> <target lang> <original file path>"
}

if test $# -ne 3; then
    echo "error: 3 arguments needed" >&2
    usage >&2
    exit 1
fi

if test ${#1} -ne 2 -a ${#2}; then
    echo "error: languages should be specified as two letter string" >&2
    usage >&2
    exit 2
fi

if test "${1}" = "${2}"; then
    echo "error: languages should be different" >&2
    usage >&2
    exit 3
fi

if ! test -f "$3"; then
    echo "error: file $3 does not exist or it is not a file" >&2
    usage >&2
    exit 4
fi

source_lang=$1
target_lang=$2

google_translate_line()
{
    local escaped="sl=$source_lang&tl=$target_lang&q=$@"
    echo $(wget -qO- \
        -U "AndroidTranslate/5.3.0.RC02.130475354-53000263 5.1 phone TRANSLATE_OPM5_TEST_1" \
        --header "'Content-Type': 'application/x-www-form-urlencoded;charset=utf-8'" \
        --header "'User-Agent': 'AndroidTranslate/5.3.0.RC02.130475354-53000263 5.1 phone TRANSLATE_OPM5_TEST_1'" \
        --post-data "$escaped" \
        "https://translate.google.com/translate_a/single?client=at&dt=t&dt=ld&dt=qca&dt=rm&dt=bd&dj=1&hl=$target_lang&ie=UTF-8&oe=UTF-8&inputm=2&otf=2&iid=1dd3b944-fa62-4b55-b330-74909a99969e")
}

get_translated_string()
{
python -c "import json
import sys

s = ' '.join(sys.argv[1:])
data = json.loads(s)
for t in data['sentences']:
    print(t['trans'])" "$@"
}

translate_line() {
    get_translated_string `google_translate_line $(echo "$@" | tr "\n" " " | tr "\r" " " | tr "\t" " ")`
}

time_string_regexp="^[[:space:]]*[0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9][[:space:]]*-->[[:space:]]*[0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9][[:space:]]*$"
counter_regexp="^[[:space:]]*[0-9]+[[:space:]]*$"

is_counter()     { [[ $@ =~ $counter_regexp ]] && echo "y" || echo "n"; }
is_time_string() { [[ $@ =~ $time_string_regexp ]] && echo "y" || echo "n"; }
is_empty()       { [[ $@ =~ ^[[:space:]]*$ ]] && echo "y" || echo "n"; }
is_text()        { ([ "n" = `is_counter $@` ] && [ "n" = `is_time_string $@` ] && [ "n" = `is_empty $@` ]) && echo "y" || echo "n"; }

ends_with_puntuation() { [[ $@ =~ [.!?]$ ]] && echo "y" || echo "n"; }

fname="${3%%.srt}"
fname="${fname%%_${source_lang}}"
outfile="${fname}_$target_lang.srt"
echo -n "" > "$outfile"

reformat_line() {
    local orig_line_number=$1
    local orig_max_length=$2
    shift
    shift
    local words=(`echo $@`)
    local written=0
    local current_lines=1
    for w in ${words[@]}; do
        if test $written -eq 0; then
            delim=""
        elif test $current_lines -lt $orig_line_number -a $(($written + ${#w} + 1)) -gt $PREFERRED_MAX_LINE_LENGTH; then
            delim="\n"
            written=0
        else
            delim=" "
        fi
        echo -en "${delim}${w}"
        written=$((${#w} + $written))
        if test "$delim" != ""; then
            written=$(($written + 1))
        fi
    done
    echo -en "\n"
}

number_of_lines=0
while read line; do
    if [ `is_counter "$line"` = "y" ]; then
        number_of_lines=$line
        break
    fi
done <<< $(tac "$3")

show_progress() {
    echo -ne "\rTranslating line $1 / $2..."
    sleep 1
}

string_buffer=""
orig_line_number=0
orig_max_length=0
id_queue=()
time_queue=()

dump_queue() {
    test ${#id_queue[@]} -ne ${#time_queue[@]} && echo "error: id_queue and time_queue have different sizes" >&2 && exit 4
    # TODO: insert here logic to meaningfully split the translated string
    local lines=("`reformat_line \"$orig_line_number\" \"$orig_max_length\" \"$string_buffer\"`")
    # local lines=("`reformat_line \"$orig_line_number\" \"$orig_max_length\" \"$(translate_line \"$string_buffer\")\"`")
    for i in `seq 0 $((${#id_queue[@]} - 1))`; do
        echo "${id_queue[$i]}" >> "$outfile"
        echo "${time_queue[$i]}" >> "$outfile"
        echo "${lines[$i]}" >> "$outfile"
        echo "" >> "$outfile"
    done
    id_queue=()
    time_queue=()
    string_buffer=""
}

while read line; do
    if [ `is_counter "$line"` = "y" ]; then
        show_progress $line $number_of_lines
        id_queue+=("$line")
    elif [ `is_time_string "$line"` = "y" ]; then
        time_queue+=("$line")
    elif [ `is_text "$line"` = "y" ]; then
        if test ${#string_buffer} -gt 0; then
            string_buffer="$string_buffer $line"
            if test ${#line} -gt $orig_max_length; then
                orig_max_length=${#line}
            fi
        else
            string_buffer="$line"
            orig_max_length=${#line}
            orig_line_number=1
        fi
        orig_line_number=$(($orig_line_number + 1))
    else
        # TODO: enable joining of subsequent subtitles uncommenting second condition
        if test ${#string_buffer} -gt 0;then # -a `ends_with_puntuation "$string_buffer"` = "y"; then
            dump_queue
        fi
    fi
done <<< `cat "$3"`

if test ${#string_buffer} -gt 0; then
    dump_queue
fi

echo " done."